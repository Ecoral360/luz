WHITESPACE = _{ " " | "\t" | "\x0b" | "\x0c" }
COMMENT    = _{ "--" ~ (longString | (!NEWLINE ~ ANY)* ~ NEWLINE?) }

Chunk = { SOI ~ block ~ EOI }

block = { stat* ~ RetStat? }

blockEnd = { (!("end" | "return") ~ stat)* ~ RetStat? ~ "end" }

RetStat = {
    "return" ~ (!"end" ~ explist)? ~ ";"? ~ NEWLINE*
}

stat = _{
    ";"
  | NEWLINE
  | AssignStat
  | FunctionCall
  | Label
  | BreakStat
  | GotoStat
  | DoStat
  | WhileStat
  | RepeatStat
  | IfStat
  | ForRangeStat
  | ForInStat
  | FunctionDefStat
  | LocalFunctionDefStat
  | LocalAssignStat
}

AssignStat      = {
    varlist ~ NEWLINE* ~ "=" ~ NEWLINE* ~ explist
}
LocalAssignStat = {
    "local" ~ nameattriblist ~ NEWLINE* ~ ("=" ~ NEWLINE* ~ explist)?
}

nameattriblist = {
    Name ~ NEWLINE* ~ (#attrib = Attrib)? ~ (NEWLINE* ~ "," ~ NEWLINE* ~ Name ~ NEWLINE* ~ (#attrib = Attrib)?)*
}
Attrib         = {
    "<" ~ Name ~ ">"
}

Label = {
    "::" ~ Name ~ "::"
}

BreakStat = { "break" }
GotoStat  = { "goto" ~ Name }

DoStat = {
    "do" ~ block ~ "end"
}

WhileStat = {
    "while" ~ exp ~ "do" ~ blockEnd
}

RepeatStat = {
    "repeat" ~ block ~ "until" ~ exp
}

blockIf = {
    (!("elseif" | "else" | "end" | "return") ~ stat)* ~ RetStat?
}

IfStat     = {
    "if" ~ exp ~ "then" ~ blockIf ~ ElseIfStat* ~ ElseStat? ~ "end"
}
ElseIfStat = {
    "elseif" ~ exp ~ "then" ~ blockIf
}
ElseStat   = {
    "else" ~ (!("end" | "return") ~ stat)* ~ RetStat?
}

ForRangeStat = {
    "for" ~ Name ~ "=" ~ exp ~ "," ~ exp ~ ("," ~ (#step = exp))? ~ "do" ~ blockEnd
}
ForInStat    = {
    "for" ~ namelist ~ "in" ~ explist ~ "do" ~ blockEnd
}

FunctionDefStat      = {
    "function" ~ funcName ~ FuncBody
}
LocalFunctionDefStat = {
    "local" ~ "function" ~ Name ~ FuncBody
}

funcName = {
    Name ~ ("." ~ Name)* ~ (":" ~ #method = Name)?
}

varlist = {
    Var ~ ("," ~ Var)*
}

Var = { prefixExp ~ (Call* ~ Access+)+ | Name }

namelist = {
    Name ~ NEWLINE* ~ (NEWLINE* ~ "," ~ Name ~ NEWLINE*)*
}

explist = {
    exp ~ NEWLINE* ~ (NEWLINE* ~ "," ~ NEWLINE* ~ exp ~ NEWLINE*)*
}

exp     =  { prefix* ~ primary ~ postfix* ~ (NEWLINE* ~ infix ~ NEWLINE* ~ prefix* ~ primary ~ postfix*)* }
prefix  = _{ unop }
postfix = _{ PostfixExp }
infix   = _{ binop }
primary = _{ Nil | Boolean | Numeral | LiteralString | Ellipse | FuncDef | TableConstructor | PrefixExp }

Ellipse = { "..." }

PrefixExp  = { prefixExp }
PostfixExp = { Access | Call }

prefixExp = _{
    Name
  | "(" ~ (#in_parent = exp) ~ ")"
}

Access = { "[" ~ exp ~ "]" | "." ~ Name }

FunctionCall = { prefixExp ~ (Access* ~ Call+)+ }

Call = { (":" ~ #method = Name)? ~ Args }
Args = {
    LiteralString
  | "(" ~ NEWLINE* ~ explist? ~ NEWLINE* ~ ")"
  | TableConstructor
}

FuncDef  = { "function" ~ FuncBody }
FuncBody = { "(" ~ NEWLINE* ~ parlist? ~ NEWLINE* ~ ")" ~ blockEnd }
parlist  = {
    namelist ~ NEWLINE* ~ ("," ~ Ellipse)?
  | Ellipse
}

TableConstructor = {
    "{" ~ Fieldlist? ~ "}"
}
Fieldlist        = {
    NEWLINE* ~ Field ~ NEWLINE* ~ (("," | ";") ~ NEWLINE* ~ Field ~ NEWLINE*)* ~ ("," | ";")? ~ NEWLINE*
}
Field            = {
    "[" ~ NEWLINE* ~ exp ~ NEWLINE* ~ "]" ~ "=" ~ exp
  | Name ~ NEWLINE* ~ "=" ~ exp
  | (#value_field = exp)
}

Name = @{ !(keywords ~ WHITESPACE) ~ (LETTER | "_") ~ (LETTER | "_" | ASCII_DIGIT)* }

Numeral = @{
    hexNumeral
  | decimalNumeral
}

hexNumeral     = {
    ("-" | "+")? ~ ^"0x" ~ ASCII_HEX_DIGIT+ ~ ("." ~ ASCII_HEX_DIGIT+)? ~ (^"p" ~ ("-" | "+")? ~ ASCII_DIGIT+)?
}
decimalNumeral = {
    ("-" | "+")? ~ ((ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT*)?) | ("." ~ ASCII_DIGIT+)) ~ (^"e" ~ ("-" | "+")? ~ ASCII_DIGIT+)?
}

LiteralString = @{ longString | shortString }

longString  = @{
    "[" ~ PUSH("=")* ~ "[" ~ NEWLINE? ~ (!("]" ~ PEEK_ALL ~ "]") ~ ANY)* ~ "]" ~ POP_ALL ~ "]"
}
shortString = @{ PUSH("\"" | "'") ~ (escape | (!PEEK ~ ANY))* ~ POP }

escape = @{
    "\\" ~ escapeChars
}

escapeChars = @{
    "a"
  | "b"
  | "f"
  | "n"
  | "r"
  | "t"
  | "v"
  | "\\"
  | "\""
  | "'"
  | NEWLINE
  | ("z" ~ WHITESPACE*)
  | ("u" ~ "{" ~ ASCII_HEX_DIGIT+ ~ "}")
  | ("x" ~ ASCII_HEX_DIGIT{2})
  | ASCII_DIGIT{1, 3}
}

// keywords tokens
Boolean = @{ "true" | "false" }
Nil     = @{ "nil" }

unop = _{
    Neg
  | Not
  | Pound
  | Bnot
}
// operator tokens
binop = _{
    And
  | Or
  | Plus
  | Minus
  | Star
  | DoubleSlash
  | Slash
  | Caret
  | Pourcent
  | Neq
  | Tilde
  | Ampersand
  | Pipe
  | ShiftRight
  | ShiftLeft
  | DotDot
  | LtEq
  | GtEq
  | Lt
  | Gt
  | Eq
}

Pound       = { "#" }
Plus        = { "+" }
Minus       = { "-" }
Neg         = { "-" }
Star        = { "*" }
Slash       = { "/" }
Pourcent    = { "%" }
Caret       = { "^" }
Ampersand   = { "&" }
Tilde       = { "~" }
Bnot        = { "~" }
Pipe        = { "|" }
ShiftLeft   = { "<<" }
ShiftRight  = { ">>" }
DoubleSlash = { "//" }
Eq          = { "==" }
Neq         = { "~=" }
LtEq        = { "<=" }
GtEq        = { ">=" }
Lt          = { "<" }
Gt          = { ">" }
DotDot      = { ".." }

And = { "and" }
Or  = { "or" }
Not = { "not" }

keywords = @{
    "and"
  | "break"
  | "do"
  | "else"
  | "elseif"
  | "end"
  | "false"
  | "for"
  | "function"
  | "goto"
  | "if"
  | "in"
  | "local"
  | "nil"
  | "not"
  | "or"
  | "repeat"
  | "return"
  | "then"
  | "true"
  | "until"
  | "while"
}
